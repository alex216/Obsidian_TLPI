1章 UNIXの歴史と標準化
    1.1 UNIXとCの略史
    1.2 Linux略史
        1.2.1 GNUプロジェクト
        1.2.2 Linuxカーネル
    1.3 標準化
        1.3.1 C言語
        1.3.2最初のPOSIX標準仕様
        1.3.3 X/OpenとTheOpenGroup
        1.3.4 SUSv3とPOSIX.1-2001
        1.3.5 SUSv4とPOSIX.1-2008
        1.3.6 UNIX標準仕様の時系列
        1.3.7実装の標準
        1.3.8 Linux、標準仕様、LinuxStandardBase
    1.4 章のまとめ
[[2章 基礎概念]]
    2.1 オペレーティングシステムのコア：カーネル
    2.2 シェル
    2.3 ユーザとグループ
    2.4 単一ディレクトリ階層、ディレクトリ、リンク、ファイル
    2.5 ファイルI/Oモデル
    2.6 プログラム
	[[2章 基礎概念#^650808|2.7 プロセス]]
    2.8 メモリマッピング
    2.9 スタティックライブラリと共有ライブラリ
    [[2章 基礎概念#^8a2e7d|2.10 プロセス間通信と同期]]
    [[2章 基礎概念#^44d3fc|2.11 シグナル]]
    [[2章 基礎概念#^a7550c|2.12 スレッド]]
    2.13 プロセスグループとジョブコントロール
    2.14 セッション、制御端末、制御プロセス
    2.15 疑似端末
    2.16 日付と時刻
    2.17 クライアント−サーバアーキテクチャ
    2.18 リアルタイム性
    2.19 /procファイルシステム
    2.20 章のまとめ
3章 システムプログラミング
    3.1 システムコール
    3.2 ライブラリ関数
    3.3 標準Cライブラリ：GNUCライブラリ（glibc）
    3.4 システムコールとライブラリ関数のエラー
    3.5 本書のサンプルプログラムについて
        3.5.1 コマンドラインオプションとパラメータ
        3.5.2 共通関数とヘッダファイル
    3.6 可搬性
        3.6.1 機能検査マクロ
        3.6.2 システムデータ型
        3.6.3 可搬性に関するその他の事柄
    3.7章のまとめ
    3.8演習
[[4章ファイル IO：統一されたインタフェース]]
    [[4章ファイル IO：統一されたインタフェース#^3fa616|4.1 概要]]
    [[4章ファイル IO：統一されたインタフェース#^c59f74|4.2 統一されたインタフェース]]
    [[4章ファイル IO：統一されたインタフェース#^79012a|4.3 ファイルのオープン：open()]]
        [[4章ファイル IO：統一されたインタフェース#^fcbbfb|4.3.1 open()へ与えるflags]]
        4.3.2 open()のエラー原因
        4.3.3 creat()システムコール
    4.4 ファイルからの読み取り：read()
    4.5 ファイルへの書き込み：write()
    4.6 ファイルのクローズ：close()
    4.7 ファイルオフセットの変更：lseek()
    4.8 統一IOモデルから外れる操作：ioctl()
    4.9 章のまとめ
    4.10 演習
[[5章ファイルIO：詳細]]
    [[5章ファイルIO：詳細#^d8e3d3|5.1 アトミック動作と競合状態]]
    5.2 ファイル操作：fcntl()
    [[5章ファイルIO：詳細#^c47b87|5.3 オープンファイルステータスフラグ]]
    [[5章ファイルIO：詳細#^c9e83c|5.4 ファイルディスクリプタとオープンしたファイルの関係]]
    5.5 ファイルディスクリプタの複製
    5.6 指定位置でのファイルI/O：`pread()`と`pwrite()`
    5.7 スキャッタ−ギャザI/O：`readv()`と`writev()`
    5.8 ファイルサイズの変更：`truncate()`と`ftruncate()`
    [[5章ファイルIO：詳細#^944e01|5.9 ノンブロッキングIO]]
    [[5章ファイルIO：詳細#^e60d69|5.10 large fileのIO]]
    5.11 /dev/fdディレクトリ
    5.12 テンポラリファイルの作成
    5.13 章のまとめ
    5.14 演習
6章 プロセス
    6.1 プロセスとプログラム
    6.2 プロセスIDと親プロセスID
    6.3 プロセスのメモリレイアウト
    6.4 仮想メモリ管理
    6.5 スタックとスタックフレーム
    6.6 コマンドラインパラメータ（argcとargv）
    6.7 環境変数
    6.8 グローバルジャンプ：setjmp()とlongjmp()
    6.9 章のまとめ
    6.10 演習
7章 メモリ割り当て
    7.1 ヒープ上のメモリ割り当て
        7.1.1 プログラムブレークの移動：brk()とsbrk()
        7.1.2 ヒープ上のメモリ割り当て：malloc()とfree()
        7.1.3 malloc()とfree()の実装
        7.1.4 ヒープ上のメモリ割り当て：その他の方法
    7.2 スタック上のメモリ割り当て：alloca()
    7.3 章のまとめ
    7.4 演習
8章 ユーザとグループ
    8.1 パスワードファイル：/etc/passwd
    8.2 shadowパスワードファイル：/etc/shadow
    8.3 グループファイル：/etc/group
    8.4 ユーザ情報とグループ情報の参照
    8.5 パスワードの暗号化とユーザ認証
    8.6 章のまとめ
    8.7 演習
9章 プロセスの権限
    9.1 実ユーザIDと実グループID
    9.2 実効ユーザIDと実効グループID
    9.3 set-user-IDとset-group-ID
    9.4 saved set-user-IDとsaved set-group-ID
    9.5 .lesystem user IDと.lesystemgroupID
    9.6 追加グループID
    9.7 プロセス権限の参照と変更
        9.7.1 実ID、実効ID、saved set IDの参照と変更
        9.7.2 filesystem user/group IDの参照と変更
        9.7.3 追加グループIDの参照と変更
        9.7.4 プロセス権限変更のまとめ
        9.7.5 サンプルプログラム：プロセス権限の表示
    9.8 章のまとめ
    9.9 演習
10章 時間
    10.1 カレンダ時間
    10.2 時刻の変換
        10.2.1 time_tの文字列変換
        10.2.2 time_tとtm構造体の相互変換
        10.2.3 tm構造体と文字列の相互変換
    10.3 タイムゾーン
    10.4 locale
    10.5 システムの時計
    10.6 ソフトウェアクロック（jif.es）
    10.7 プロセス時間
    10.8 章のまとめ
    10.9 演習
11章 システムの制限とオプション機能
    11.1 システムの制限
    11.2 制限とオプション機能の参照
    11.3 ファイル関連の制限とオプション機能の参照
    11.4 未確定値
    11.5 オプション機能
    11.6 章のまとめ
    11.7 演習
12章 システム情報とプロセス情報
    12.1 /procファイルシステム
        12.1.1プロセス情報の参照：/proc/PID
        12.1.2 /proc下のシステム情報
        12.1.3 /proc下のファイルへのアクセス
        12.1.4 /proc/PID下のファイルへのアクセス
    12.2 システムの識別：uname()
    12.3 章のまとめ
    12.4 演習
[[13章 IOのバッファリング]]
    13.1 カーネルによるバッファリング：バッファキャッシュ
    [[13章 IOのバッファリング#^85ebb3|13.2 stdioライブラリによるバッファリング]]
    [[13章 IOのバッファリング#^f76ae4|13.3 カーネルバッファのフラッシュ]]
    13.4 IOバッファリングのまとめ
    13.5 アクセスパターンの通知
    [[13章 IOのバッファリング#^a66c2b|13.6 バッファリングを無効にする：DirectIO]]
    13.7 システムコールとライブラリ関数の混用
    13.8 章のまとめ
    13.9 演習
14章 ファイルシステム
    14.1 デバイススペシャルファイル
    14.2 ディスクとパーティション
    14.3 ファイルシステム
    14.4 i-node
    14.5 VFS
    14.6 ジャーナリングファイルシステム
    14.7 ディレクトリツリーとマウントポイント
    14.8 ファイルシステムのマウントとアンマウント
        14.8.1 ファイルシステムのマウント：mount()
        14.8.2 ファイルシステムのアンマウント：umount()とumount2()
    14.9 高度なマウント
        14.9.1 デバイスの複数マウント
        14.9.2 マウントポイントへの複数マウント
        14.9.3 マウント単位のオプションとマウントフラグ
        14.9.4 bindマウント
        14.9.5 再帰bindマウント
    14.10 仮想メモリファイルシステム：tmpfs
    14.11 ファイルシステム情報：statvfs()
    14.12 章のまとめ
    14.13 演習
15章 ファイルの属性
    15.1 ファイル情報の取得：stat()
    15.2 タイムスタンプ
        15.2.1 ファイルタイムスタンプの変更：utime()とutimes()
        15.2.2 タイムスタンプの変更：utimensat()とfutimens()
    15.3 ファイルオーナ
        15.3.1 新規ファイルのオーナ
        15.3.2 ファイルオーナの変更：chown()、fchown()、lchown()
    15.4 ファイルパーミション
        15.4.1 通常ファイルのパーミション
        15.4.2 ディレクトリのパーミション
        15.4.3 パーミション検査アルゴリズム
        15.4.4 アクセス可否の検査：access()
        15.4.5 set-user-ID、set-group-ID、スティッキービット
        15.4.6 ファイル作成マスク：umask()
        15.4.7 パーミションの変更：chmod()とfchmod()
    15.5 i-nodeフラグ（ext2の拡張ファイル属性）
    15.6 章のまとめ
    15.7 演習
16章 ファイルの拡張属性
    16.1 概要
    16.2 拡張属性の詳細
    16.3 拡張属性の操作
    16.4 章のまとめ
    16.5 演習
17章 ACL
    17.1 概要
    17.2 ACL検査アルゴリズム
    17.3 ACLのテキスト表現
    17.4 ACL_MASKエントリとACLグループクラス
    17.5 getfaclとsetfaclコマンド
    17.6 ディフォルトACLとファイル新規作成
    17.7 ACLの実装上の制限
    17.8 ACLAPI
    17.9 章のまとめ
    17.10 演習
[[18章 ディレクトリとリンク]]
    18.1 ディレクトリと（ハード）リンク
    18.2 シンボリック（ソフト）リンク
    18.3 （ハード）リンクの作成/削除：link()とunlink()
    18.4 ファイル名の変更：rename()
    18.5 シンボリックリンクの作成/参照：symlink()とreadlink()
    18.6 ディレクトリの作成/削除：mkdir()とrmdir()
    18.7 ファイルとディレクトリの削除：remove()
    [[18章 ディレクトリとリンク#^9c707a|18.8 ディレクトリの読み取り：opendir()とreaddir()]]
    18.9 ファイルツリーウォーク：nftw()
    18.10 プロセスのカレントワーキングディレクトリ
    18.11 検索開始ディレクトリと相対パス
    18.12 プロセスのルートディレクトリの変更：chroot()
    18.13 パス名の解決：realpath()
    18.14 パス名の解析：dirname()とbasename()
    18.15 章のまとめ
    18.16 演習
19章 ファイルイベント
    19.1 概要
    19.2 inotifyAPI
    19.3 inotifyイベント
    19.4 inotifyイベントの読み取り
    19.5 キューの上限と/procファイル
    19.6 ファイルイベント監視の古い方法：dnotify
    19.7 章のまとめ
    19.8 演習
[[20章 シグナル：基礎]]
    20.1 基礎概念と概要
    20.2 シグナル種類とディフォルト動作
    20.3 シグナル動作の変更：signal()
    20.4 シグナルハンドラ
	[[20章 シグナル：基礎#^0e3b24|20.5 シグナルの送信：kill()]]
    20.6 プロセスの存在確認
    20.7 シグナル送信の他の方法：raise()とkillpg()
    20.8 シグナルの説明文字列
    20.9 シグナルセット
    20.10 シグナルマスク（シグナルのブロック）
    20.11 シグナルの保留
    20.12 キューイングされないシグナル
    20.13 シグナル動作の変更：sigaction()
    20.14 シグナルを待つ：pause()
    20.15 章のまとめ
    20.16 演習
21章 シグナル：シグナルハンドラ
    21.1 シグナルハンドラの設計
        21.1.1 シグナルはキューイングされない（再考）
        21.1.2 リエントラントと非同期シグナルセーフ
        21.1.3 グローバル変数とsig_atomic_t型
    21.2 シグナルハンドラの終了：他の方法
        21.2.1 シグナルハンドラからのグローバルジャンプ
        21.2.2 プロセスの異常終了：abort()
    21.3 シグナル処理専用スタック：sigaltstack()
    21.4 SA_SIGINFOフラグ
    21.5 システムコールへの割り込みと再開
    21.6 章のまとめ
    21.7 演習
[[22章 シグナル：応用]]
    22.1 コアダンプ
    22.2 シグナル受信、シグナル動作、シグナル処理の特殊な例
    22.3 プロセスの状態：割り込み可能/不可のスリープ
    22.4 ハードウェアが生成するシグナル
    22.5 シグナルの同期生成と非同期生成
    22.6 シグナル受信のタイミングと順序
    22.7 signal()の実装と可搬性
    22.8 リアルタイムシグナル
        22.8.1 リアルタイムシグナルの送信
        22.8.2 リアルタイムシグナルの処理
    [[22章 シグナル：応用#^743c8a|22.9 シグナルマスクとシグナル待ち合わせ：sigsuspend()]]
    22.10 同期的にシグナルを待つ
    22.11 ファイルディスクリプタ経由のシグナル受信
    22.12 シグナルを用いたプロセス間通信
    22.13 太古のシグナルAPI（SystemVとBSD）
    22.14 章のまとめ
    22.15 演習
23章 タイマとスリープ
    23.1 インターバルタイマ
    23.2 スケジューリングとタイマ精度
    23.3 ブロックする処理のタイムアウト設定
    23.4 時間指定の実行停止（スリープ）
        23.4.1 低解像度のスリープ：sleep()
        23.4.2 高解像度スリープ：nanosleep()
    23.5 POSIXクロック
        23.5.1 クロック値の取得：clock_gettime()
        23.5.2 クロック値の変更：clock_settime()
        23.5.3 プロセス/スレッドごとのクロック
        23.5.4 高精度のスリープ：clock_nanosleep()
    23.6 POSIXインターバルタイマ
        23.6.1 タイマの作成：timer_create()
        23.6.2 タイマの開始と終了：timer_settime()
        23.6.3 タイマ値の取得：timer_gettime()
        23.6.4 タイマの削除：timer_delete()
        23.6.5 シグナルによる通知
        23.6.6 タイマオーバラン
        23.6.7 スレッド起動による通知
    23.7 ファイルディスクリプタ経由のタイマ通知：timerfd API
    23.8 章のまとめ
    23.9 演習
[[24章 プロセス作成]]
    [[24章 プロセス作成#^cb5914|24.1 概要：fork()、exit()、wait()、execve()]]
    [[24章 プロセス作成#^b64151|24.2 プロセスの作成：fork()]]
        24.2.1 親子プロセス間のファイル共有
        24.2.2 fork()のメモリ処理
    24.3 vfork()システムコール
    [[24章 プロセス作成#^592f2f|24.4 fork()後の競合状態]]
    [[24章 プロセス作成#^fc3c85|24.5 シグナルによる同期を用いた競合状態防止]]
    [[24章 プロセス作成#^cd3935|24.6 章のまとめ]]
    24.7 演習
[[25章 プロセスの終了]]
    [[25章 プロセスの終了#^320bbc|25.1 \_exit()とexit()]]
    25.2 終了処理詳細
	[[25章 プロセスの終了#^895e5b|25.3 exitハンドラ]]
    25.4 fork()とstdioバッファの関係
    25.5 章のまとめ
    25.6 演習
[[26章 子プロセスの監視]]
    [[26章 子プロセスの監視#^d71141|26.1 子プロセスの終了を待つ]]
        [[26章 子プロセスの監視#^3bb878|26.1.1 wait()システムコール]]
        [[26章 子プロセスの監視#^052e0b|26.1.2 waitpid()システムコール]]
        26.1.3 wait()のstatus
        26.1.4 シグナルハンドラからのプロセス終了
        26.1.5 waitid()システムコール
        26.1.6 wait3()とwait4()システムコール
    26.2 孤児プロセスとゾンビプロセス
    26.3 SIGCHLDシグナル
        26.3.1 SIGCHLDハンドラの設定
        26.3.2 子プロセスが一時停止した場合のSIGCHLD
        26.3.3 終了した子プロセスの無視
    26.4 章のまとめ
    26.5 演習
[[27章 プログラムの実行]]
    27.1 プログラムの実行：execve()
    27.2 exec()ファミリ
        27.2.1 環境変数PATH
        27.2.2 パラメータリスト
        27.2.3 親プロセスの環境を渡す
        27.2.4 ファイルディスクリプタ指定によるプログラム実行：fexecve()
    27.3 インタプリタのスクリプト
    [[27章 プログラムの実行#^1cda82|27.4 ファイルディスクリプタとexec()]]
    27.5 シグナルとexec()
    27.6 コマンド実行：system()
    27.7 system()の実装
    27.8 章のまとめ
    27.9 演習
28章 プロセスの作成とプログラムの実行：詳細
    28.1 プロセスアカウンティング
    28.2 clone()システムコール
        28.2.1 clone()のflags
        28.2.2 clone()後にwaitpid()するための拡張フラグ
    28.3 プロセス作成の速度性能
    28.4 fork()とexec()がプロセス属性に与える影響
    28.5 章のまとめ
    28.6 演習
29章 スレッド：基礎
    29.1 概要
    29.2 Pthreads APIの基本事項
    29.3 スレッドの作成
    29.4 スレッドの終了
    29.5 スレッドID
    29.6 スレッドの終了を待つ
    29.7 スレッドのデタッチ
    29.8 スレッド属性
    29.9 スレッドとプロセス
    29.10 章のまとめ
    29.11 演習
30章 スレッド：同期
    30.1 共有変数の保護：mutex
        30.1.1 スタティックに割り当てたmutex
        30.1.2 mutexのロックとアンロック
        30.1.3 mutexの性能
        30.1.4 mutexのデッドロック
        30.1.5 mutexのダイナミックな初期化
        30.1.6 mutexの属性
        30.1.7 mutexの種類
    30.2 状態変化の通知：条件変数
        30.2.1 スタティックに割り当てた条件変数
        30.2.2 条件変数による通知と待機
        30.2.3 条件変数が持つ意味
        30.2.4 サンプルプログラム：終了したスレッドのjoin
        30.2.5 ダイナミックに割り当てた条件変数
    30.3 章のまとめ
    30.4 演習
31章 スレッド：スレッドセーフと専用メモリ
    31.1 スレッドセーフ（リエントラント再考）
    31.2 ワンタイムイニシャライゼーション
    31.3 スレッド固有データ
        31.3.1 ライブラリ関数から見たスレッド固有データ
        31.3.2 スレッド固有データAPI：概要
        31.3.3 スレッド固有データAPI：詳細
        31.3.4 スレッド固有データAPI：実例
        31.3.5 スレッド固有データ実装上の制限
    31.4 スレッドローカルストレージ
    31.5 章のまとめ
    31.6 演習
32章 スレッド：キャンセル
    32.1 スレッドのキャンセル
    32.2 キャンセル状態と種類
    32.3 キャンセルポイント
    32.4 キャンセル要求の検査
    32.5 クリーンナップハンドラ
    32.6 非同期キャンセル
    32.7 章のまとめ
33章 スレッド：さらなる詳細
    33.1 スレッドスタック
    33.2 スレッドとシグナル
        33.2.1 UNIXシグナルモデルとの整合
        33.2.2 スレッドシグナルマスクの操作
        33.2.3 スレッドへのシグナル送信
        33.2.4 非同期シグナルへの対応
    33.3 スレッド/プロセスの制御
    33.4 スレッドモデル
    33.5 LinuxのPOSIXスレッドライブラリ
        33.5.1 LinuxThreads
        33.5.2 NPTL
        33.5.3 どちらのスレッドライブラリ?
    33.6 Pthreads APIの先進機能
    33.7 章のまとめ
    33.8 演習
[[34章 プロセスグループ、セッション、ジョブコントロール]]
    [[34章 プロセスグループ、セッション、ジョブコントロール#^67b2c8|34.1 概要]]
    [[34章 プロセスグループ、セッション、ジョブコントロール#^e8230d|34.2 プロセスグループ]]
    34.3 セッション
    34.4 制御端末と制御プロセス
    34.5 フォアグラウンド/バックグラウンドプロセスグループ
    34.6 SIGHUPシグナル
        34.6.1 シェルのSIGHUP処理
        34.6.2 SIGHUPと制御プロセスの終了
    34.7 ジョブコントロール
        34.7.1 ジョブコントロールの使用方法
        34.7.2 ジョブコントロールの実装
        34.7.3 ジョブコントロールシグナル
        34.7.4 孤児プロセスグループ（SIGHUP再考）
    34.8 章のまとめ
    34.9 演習
35章 プロセスの優先度とスケジューリング
    35.1 プロセスの優先度（nice値）
    35.2 リアルタイムプロセススケジューリング
        35.2.1 SCHED_RRポリシー
        35.2.2 SCHED_FIFOポリシー
        35.2.3 SCHED_BATCHポリシーとSCHED_IDLEポリシー
    35.3 リアルタイムプロセススケジューリングAPI
        35.3.1 リアルタイム優先度の範囲
        35.3.2 ポリシーと優先度の設定/参照
        35.3.3 CPUを手離す
        35.3.4 SCHED_RRポリシーのタイムスライス
    35.4 CPUアフィニティ
    35.5 章のまとめ
    35.6 演習
36章 プロセスのリソース
    36.1 プロセスのリソース消費
    36.2 プロセスのリソース消費制限
    36.3 各リソース消費制限の詳細
    36.4 章のまとめ
    36.5 演習
37章 デーモン
    37.1 概要
    37.2 プロセスのデーモン化
    37.3 デーモン化ガイドライン
    37.4 SIGHUPによる再初期化
    37.5 syslogによるログ出力
        37.5.1 概要
        37.5.2 syslog API
        37.5.3 /etc/syslog.conf
    37.6 章のまとめ
    37.7 演習
38章 セキュアな特権プログラムの開発
    38.1 set-user-IDとset-group-IDの必要性の再検討
    38.2 最小の権限
    38.3 外部プログラムの実行には細心の注意を
    38.4 情報の機密保持
    38.5 プロセスに課すセキュリティ上の制約
    38.6 シグナルと競合状態
    38.7 ファイル操作とファイルI/O時の落とし穴
    38.8 ユーザ入力や環境を信頼してはいけない
    38.9 バッファオーバラン予防策
    38.10 DoSアタック対策
    38.11 戻り値やエラーを確実に確認する
    38.12 章のまとめ
    38.13 演習
39章 ケーパビリティ
    39.1 ケーパビリティの目的
    39.2 Linuxのケーパビリティ
    39.3 プロセスとファイルのケーパビリティ
        39.3.1 プロセスケーパビリティ
        39.3.2 ファイルケーパビリティ
        39.3.3 プロセスのpermittedケーパビリティセットとeffectiveケーパビリティセット
        39.3.4 ファイルのpermittedケーパビリティセットとeffectiveケーパビリティセット
        39.3.5 プロセスのinheritableケーパビリティセットとファイルのinheritableケーパビリティセット
        39.3.6 シェルからのファイルケーパビリティセットの設定と参照
    39.4 現代のケーパビリティ実装
    39.5 exec()とプロセスケーパビリティ
        39.5.1 ケーパビリティバウンディングセット
        39.5.2 root権限
    39.6 ユーザID変更とプロセスケーパビリティ
    39.7 プログラムからのプロセスケーパビリティ変更
    39.8 ケーパビリティの作成（環境のみ）
    39.9 プログラムに必要なケーパビリティの特定
    39.10 ファイルケーパビリティ未対応のカーネルやシステム
    39.11 章のまとめ
    39.12 演習
40章 ログインアカウンティング
    40.1 utmpファイルとwtmpファイル
    40.2 utmpx API
    40.3 utmpx構造体
    40.4 utmpファイルとwtmpファイルの参照
    40.5 ログイン名の参照：getlogin()
    40.6 ログインセッションによるutmpおよびwtmpファイルの更新
    40.7 lastlogファイル
    40.8 章のまとめ
    40.9 演習
41章 共有ライブラリ：基礎
    41.1 オブジェクトライブラリ
    41.2 スタティックライブラリ
    41.3 共有ライブラリの概要
    41.4 共有ライブラリの作成と使用−初めの一歩
        41.4.1 共有ライブラリの作成
        41.4.2 PIC
        41.4.3 共有ライブラリの使用
        41.4.4 共有ライブラリのsoname
    41.5 共有ライブラリ関連ツール
    41.6 共有ライブラリのバージョンと命名規則
    41.7 共有ライブラリのインストール
    41.8 ライブラリのバージョンアップと互換性
    41.9 共有ライブラリの更新
    41.10 オブジェクトファイルによるライブラリ検索パス指定
    41.11 実行時共有ライブラリ検索
    41.12 実行時シンボル解決
    41.13 共有ライブラリをスタティックライブラリで置き換える
    41.14 章のまとめ
    41.15 演習
42章 共有ライブラリ：応用
    42.1 ダイナミックロード
        42.1.1 共有ライブラリのオープン：dlopen()
        42.1.2 エラー診断：dlerror()
        42.1.3 シンボル参照：dlsym()
        42.1.4 共有ライブラリのクローズ：dlclose()
        42.1.5 シンボルの情報：dladdr()
        42.1.6 メインプログラム内のシンボルへのアクセス
    42.2 シンボル公開の制御
    42.3 リンカのバージョンスクリプト
        42.3.1 シンボル公開の可否
        42.3.2 シンボルのバージョン管理
    42.4 初期化処理と終了処理
    42.5 プリロード
    42.6 ダイナミックリンカのトレース：LD_DEBUG
    42.7 章のまとめ
    42.8 演習
43章 プロセス間通信：概論
    43.1 IPCの分類
    43.2 通信機構
    43.3 同期機構
    43.4 IPCの比較
    43.5 章のまとめ
    43.6 演習
[[44章 パイプとFIFO]]
    44.1 概要
    44.2 パイプの作成と使用
    44.3 パイプによるプロセス同期
    44.4 パイプによるフィルタ連結
    44.5 パイプとシェルコマンドの連結：popen()
    44.6 パイプとstdioのバッファリング
    44.7 FIFO
    44.8 FIFOを用いたクライアント−サーバアプリケーション
    [[44章 パイプとFIFO#^a116a5|44.9 ノンブロッキングIO]]
    44.10 パイプとFIFOのread()およびwrite()
    44.11 章のまとめ
    44.12 演習
45章 SystemV IPC：基礎
    45.1 API概要
    45.2 IPCキー
    45.3 IPCオブジェクトの対応構造体とパーミション
    45.4 IPC IDとクライアント−サーバアプリケーション
    45.5 SystemVIPC getのアルゴリズム
    45.6 ipcsコマンドとipcrmコマンド
    45.7 全IPCオブジェクトの一覧
    45.8 IPCの上限
    45.9 章のまとめ
    45.10 演習
46章 SystemVメッセージキュー
    46.1 メッセージキューの作成とオープン
    46.2 メッセージの交換
        46.2.1 メッセージの送信
        46.2.2 メッセージの受信
    46.3 メッセージキューの制御
    46.4 メッセージキューの対応構造体
    46.5 メッセージキューの上限値
    46.6 全メッセージキューの表示
    46.7 メッセージキューによるクライアント−サーバアプリケーション
    46.8 メッセージキューを用いたファイルサーバ
    46.9 SystemVメッセージキューの短所
    46.10 章のまとめ
    46.11 演習
47章 SystemVセマフォ
    47.1 概要
    47.2 セマフォセットの作成とオープン
    47.3 セマフォ制御
    47.4 対応構造体
    47.5 セマフォの初期化
    47.6 セマフォ操作
    47.7 複数セマフォ操作のブロック
    47.8 セマフォのundo
    47.9 バイナリセマフォの実装
    47.10 セマフォの上限値
    47.11 SystemVセマフォの短所
    47.12 章のまとめ
    47.13 演習
48章 SystemV共有メモリ
    48.1 概要
    48.2 共有メモリセグメントの作成とオープン
    48.3 共有メモリの使用
    48.4 サンプル：共有メモリによるデータ転送
    48.5 仮想メモリ内での共有メモリ配置
    48.6 共有メモリへのポインタ代入
    48.7 共有メモリの制御
    48.8 共有メモリ対応構造体
    48.9 共有メモリの上限
    48.10 章のまとめ
    48.11 演習
49章 メモリマッピング
    49.1 概要
    49.2 マッピングの作成：mmap()
    49.3 マッピングの削除：munmap()
    49.4 ファイルマッピング
        49.4.1 非共有ファイルマッピング
        49.4.2 共有ファイルマッピング
        49.4.3 マッピング範囲とページ境界
        49.4.4 メモリ保護フラグとファイルアクセスモード
    49.5 マッピング領域とファイルの同期：msync()
    49.6 mmap()のその他のフラグ
    49.7 無名マッピング
    49.8 マッピングの再マップ：mremap()
    49.9 MAP_NORESERVEとオーバコミット
    49.10 MAP_FIXEDフラグ
    49.11 非リニアマッピング：remap_file_pages()
    49.12 章のまとめ
    49.13 演習
50章 仮想メモリ操作
    50.1 メモリ保護フラグの変更：mprotect()
    50.2 メモリのロック：mlock()とmlockall()
    50.3 ページ存在の検査：mincore()
    50.4 メモリアクセスパターンのヒント：madvise()
    50.5 章のまとめ
    50.6 演習
51章 POSIX IPC：基礎
    51.1 API概要
    51.2 SystemVIPCとPOSIX IPCの比較
    51.3 章のまとめ
52章 POSIXメッセージキュー
    52.1 概要
    52.2 メッセージキューのオープン、クローズ、削除
    52.3 メッセージキューとディスクリプタの関係
    52.4 メッセージキューの属性
    52.5 メッセージの交換
        52.5.1 メッセージの送信
        52.5.2 メッセージの受信
        52.5.3 メッセージ送受信のタイムアウト
    52.6 新着メッセージ通知
        52.6.1 シグナルによる通知
        52.6.2 スレッド起動による通知
    52.7 Linux固有の機能
    52.8 メッセージキューの上限
    52.9 POSIXメッセージキューとSystemVメッセージキューの比較
    52.10 章のまとめ
    52.11 演習
53章 POSIXセマフォ
    53.1 概要
    53.2 名前付きセマフォ
        53.2.1 名前付きセマフォのオープン
        53.2.2 名前付きセマフォのクローズ
        53.2.3 名前付きセマフォの削除
    53.3 セマフォ操作
        53.3.1 セマフォの獲得
        53.3.2 セマフォの解放
        53.3.3 セマフォの現在値の参照
    53.4 無名セマフォ
        53.4.1 無名セマフォの初期化
        53.4.2 無名セマフォの破棄
    53.5 他の同期機構との比較
    53.6 セマフォの上限
    53.7 章のまとめ
    53.8 演習
54章 POSIX共有メモリ
    54.1 概要
    54.2 共有メモリオブジェクトの作成
    54.3 共有メモリオブジェクトの使用
    54.4 共有メモリオブジェクトの削除
    54.5 共有メモリAPIの比較
    54.6 章のまとめ
    54.7 演習
55章 ファイルロック
    55.1 概要
    55.2 flock()によるファイルロック
        55.2.1 ロックの継承と解放
        55.2.2 flock()の制限事項
    55.3 fcntl()によるレコードロック
        55.3.1 デッドロック
        55.3.2 サンプル：インタラクティブなロックプログラム
        55.3.3 サンプル：汎用ロック関数
        55.3.4 ロックの上限と性能
        55.3.5 ロックの継承と解放
        55.3.6 スターベィションとキューイングされたロック要求の優先度
    55.4 強制ロック
    55.5 /proc/locks
    55.6 プログラム実行を1インスタンスに制限する
    55.7 従来のロック方法
    55.8 章のまとめ
    55.9 演習
56章 ソケット：基礎
    56.1 概要
    56.2 ソケットの作成：socket()
    56.3 ソケットアドレスのバインド：bind()
    56.4 汎用ソケットアドレス構造体：struct sockaddr
    56.5 ストリームソケット
        56.5.1 接続要求の受け付け：listen()
        56.5.2 コネクションの受け付け：accept()
        56.5.3 ピアソケットへの接続：connect()
        56.5.4 ストリームソケットのI/O
        56.5.5 コネクションの終了：close()
    56.6 データグラムソケット
        56.6.1 データグラムの交換：recvfrom()とsendto()
        56.6.2 データグラムソケットのconnect()
    56.7 章のまとめ
57章 ソケット：UNIXドメイン
    57.1 UNIXドメインのソケットアドレス：struct sockaddr_un
    57.2 UNIXドメインのストリームソケット
    57.3 UNIXドメインのデータグラムソケット
    57.4 UNIXドメインソケットのパーミション
    57.5 接続済みソケットペアの作成：socketpair()
    57.6 Linuxの抽象ソケット名前空間
    57.7 章のまとめ
    57.8 演習
58章 ソケット：TCP/IPネットワークの基礎
    58.1 インターネット
    58.2 ネットワークプロトコルとレイヤ
    58.3 データリンク層
    58.4 ネットワーク層：IP
    58.5 IPアドレス
    58.6 トランスポート層
        58.6.1 ポート番号
        58.6.2 UDP（UserDatagramProtocol）
        58.6.3 TCP（TransmissionControlProtocol）
    58.7 RFC（Request forComments）
    58.8 章のまとめ
59章 ソケット：インターネットドメイン
    59.1 インターネットドメインソケット
    59.2 ネットワークバイトオーダ
    59.3 データ表現
    59.4 インターネットソケットアドレス
    59.5 ホスト名およびサービス名変換関数の概要
    59.6 inet_pton()とinet_ntop()
    59.7 データグラムソケットのサンプル：クライアント−サーバプログラム
    59.8 DNS（ドメインネームシステム）
    59.9 /etc/services
    59.10 ホスト名およびサービス名のプロトコルに依存しない変換
        59.10.1 getaddrinfo()
        59.10.2 addrinfoのアドレス構造体リストの解放：freeaddrinfo()
        59.10.3 エラー診断：gai_strerror()
        59.10.4 getnameinfo()
    59.11 ストリームソケットのサンプル：クライアント−サーバプログラム
    59.12 インターネットドメインソケットライブラリ
    59.13 ホスト名とサービス名を変換する従来のAPI
        59.13.1 inet_aton()とinet_ntoa()
        59.13.2 gethostbyname()とgethostbyaddr()
        59.13.3 getservbyname()とgetservbyport()
    59.14 UNIXドメインソケットとインターネットドメインソケット
    59.15 追加情報
    59.16 章のまとめ
    59.17 演習
60章 ソケット：サーバ設計
    60.1 反復サーバと並行サーバ
    60.2 UDP echo反復サーバ
    60.3 TCP echo並行サーバ
    60.4 並行サーバの他の設計
    60.5 inetd（インターネットスーパサーバデーモン）
    60.6 章のまとめ
    60.7 演習
[[61章 ソケット：応用]]
    61.1 ストリームソケットの部分読み取りと部分書き込み
    61.2 shutdown()システムコール
    61.3 ソケット専用I/Oシステムコール：recv()とsend()
    61.4 sendfile()システムコール
    61.5 ソケットアドレスの参照
    61.6 TCPの詳細
        61.6.1 TCPセグメントの形式
        61.6.2 TCPのシーケンス番号と確認応答
        61.6.3 TCPのステートマシンと状態遷移図
        61.6.4 TCPコネクションの確立
        61.6.5 TCPコネクションの切断
        61.6.6 TCPソケットに対するshutdown()
        61.6.7 TIME_WAIT状態
    61.7 ソケットの監視：netstat
    61.8 TCPトラフィックの監視：tcpdump
    61.9 ソケットオプション
    61.10 SO_REUSEADDRソケットオプション
    61.11 accept()時のフラグとオプションの継承
    61.12 TCP対UDP
    61.13 高度な機能
        61.13.1 帯域外データ
        61.13.2 sendmsg()システムコールとrecvmsg()システムコール
        [[61章 ソケット：応用#^56af04|61.13.3 ファイルディスクリプタの送受信]]
        61.13.4 権限の送受信
        61.13.5 シーケンスパケットソケット
        61.13.6 トランスポート層：SCTPとDCCP
    61.14 章のまとめ
    61.15 演習
62章 端末
    62.1 概要
    62.2 端末属性の設定と参照
    62.3 sttyコマンド
    62.4 特殊文字
    62.5 端末フラグ
    62.6 端末のI/Oモード
        62.6.1 canonicalモード
        62.6.2 noncanonicalモード
        62.6.3 cookedモード、cbreakモード、rawモード
    62.7 端末回線速度（ビットレート）
    62.8 端末回線制御
    62.9 端末ウィンドウサイズ
    62.10 端末の特定
    62.11 章のまとめ
    62.12 演習
[[63章 高度なIOモデル]]
    63.1 概要
        63.1.1 レベルトリガ通知とエッジトリガ通知
        63.1.2 高度なI/OモデルでのノンブロッキングI/O
    63.2 多重I/O
        63.2.1 select()システムコール
        63.2.2 poll()システムコール
        63.2.3 I/O可能判定の要件
        63.2.4 select()とpoll()の比較
        63.2.5 select()とpoll()の問題点
    [[63章 高度なIOモデル#^7a9dbe|63.3 シグナルドリブンIO]]
        63.3.1 I/O可能通知シグナルが送信されるのはいつか
        63.3.2 シグナルドリブンI/Oの高度な使用
    63.4 epoll API
        63.4.1 epollインスタンスの作成：epoll_create()
        63.4.2 epollインタレストリストの変更：epoll_ctl()
        63.4.3 epollイベントを待つ：epoll_wait()
        63.4.4 epoll動作の詳細
        63.4.5 多重I/Oとepollの性能比較
        63.4.6 エッジトリガ通知
    63.5 シグナル待ちとファイルディスクリプタ待ち
        63.5.1 pselect()システムコール
        63.5.2 self-pipe
    63.6 章のまとめ
    63.7 演習
64章 疑似端末
    64.1 概要
    64.2 UNIX 98疑似端末
        64.2.1 疑似端末マスタデバイスのオープン：posix_openpt()
        64.2.2 スレーブデバイスのオーナおよびパーミションの変更：grantpt()
        64.2.3 スレーブデバイスのアンロック：unlockpt()
        64.2.4 スレーブデバイス名の取得：ptsname()
    64.3 マスタデバイスのオープン：ptyMasterOpen()
    64.4 疑似端末へのプロセスの接続：ptyFork()
    64.5 疑似端末I/O
    64.6 script（1）の実装
    64.7 端末属性とウィンドウサイズ
    64.8 BSD疑似端末
    64.9 章のまとめ
    64.10 演習

2012年12月