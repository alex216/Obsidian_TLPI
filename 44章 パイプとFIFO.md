- 1970年代初頭にThird Edition UNIXで実装された最も歴史あるUNIXシステムのIPC
- FIFOは任意のプロセス間で使用できる
- 44.1 概要 ^a671cc
	- バイトストリーム
		- メッセージやメッセージ区切りという概念を持たない
		- ランダムアクセスできない
		- 区切りをメッセージならFIFOを用いたアプリケーションを作れば実現できるが、メッセージキューやデータグラムソケット等他のIPCを採用した方がいい
	- パイプの読み取り
		- 書き込まれていないパイプを読み取ろうとするとデータが書き込まれるまでブロックする
		- パイプないの全データを読み取り後end-of-fileを読み取る
	- 一方向性
		- System V Release 4派生では双方向性でstream pipeと呼ぶ
		- UNIXドメインのストリームソケットペアの`socketpair()`で実現できる
	- `PIPE_BUF`とアトミック書き込み
		- 複数プロセスの書き込みは混ざることがない
			- 条件：`PIPE_BUF`を一度に超過しなければ
	- パイプ容量の上限
		- パイプの実体はカーネルが管理するバッファ
		- Linux 2.6.11以降では2^16バイト
		- 理論的には１バイトでも動作可能
			- コンテキストスイッチで読み取りプロセスをスケジューリングする回数が増える
			- Linux 2.6.35以降でパイプバッファ容量が変更可能になった
				- `fcntl(fd, F_SETPIPE_SZ, size)`
			- `fcntl(fd, F_GETPIPE_SZ)`で取得可能
- 44.2 パイプの作成と使用 ^109455
	- fdに対し、`fdopen()`は`stdio関数(printf(), scanf())`も使用可能([[13章 IOのバッファリング#^9fd4ae|13.7]])
		- stdioが内部でバッファリングする点に注意（[[44章 パイプとFIFO#^256c7a|44.6]]）
	- `ioctl(fd, FIONREAD, &cnt)`はパイプやFIFOに残るバイト数を取得できる
	- １プロセスでのパイプの使い道はほぼない([[63章 高度なIOモデル#^98416a|63.5.2 self-pipe]])
	- ２プロセスをパイプで連結するには`pipe()`に加え`fork()`を使う([[24章 プロセス作成#^69c470|24.2.1]])
	- 読み込みプロセスが２つ：競合状態を起こす
		- 回避するには同期が必要
		- 双方向通信が必須ならもっと簡単に送信用、受信用２つのパイプを作ればいい
			- パイプがいっぱいor空になるデッドロックに注意
	- 書き込みプロセスが複数
		- [[44章 パイプとFIFO#^6ce218|44.3]]参照 ^31368a
		- FIFOでは有用なケースがある([[44章 パイプとFIFO#^423501|44.8]])
	- 非標準だがLinux 2.6.27から`pipe2()`が追加
		- 引数flagsが二つ実装されている
			- `O_CLOEXEC`　close-on-execフラグと同様
			- `O_NONBLOCK`　IOがノンブロック
	- 関連プロセス間で通信するパイプ
		- 親孫間でも通信できる
		- 兄弟間でも通信できる（シェルがパイプラインを作成する際の実行処理）
	- パイプfdのクローズ
		- 書き込み口をクローズしないとend-of-fileが読み込めない
			- `read()`がブロックするので処理が終わらない
		- 読み取り口をクローズしないと
			- パイプが最終的にいっぱいになりその後の書き込みは永久にブロックする
			- もし本来の読み取り口がクローズしている時、ちゃんと`SIGPIPE`が発生してくれるから
		- 不要なパイプのクローズはリソースの解放
- 44.3 パイプによるプロセス同期 ^6ce218
	- [[24章 プロセス作成#^fc3c85|24.5]]ではシグナルでの親子プロセス競合の回避をした。パイプでも可能。
	- 親プロセス`read()`がend-of-fileを読み取り、同期する
	- パイプ同期のメリット
		- １プロセスが他複数と同期できる
	- シグナル同期のメリット
		- １プロセスからのブロードキャストが可能
- 


- 44.6 パイプとstdioのバッファリング ^256c7a

- 44.8 FIFOを用いたクライアント−サーバアプリケーション
 ^423501
- 44.9 ノンブロッキングI/O ^a116a5
	- FIFOの他方がまだオープンしてない場合に有効なフラグ
		- 読み取り用にオープン
			- 書き込み用fdがオープンしているプロセスがなくても`open()`が成功するようになる
		- 書き込み用にオープン
			- 読み込み用にオープン済みプロセスが存在しなければ`open()`が成功せず`ENXIO`エラーを返す
		- ![[Pasted image 20240313182308.png]]
	- 目的２つ
		- １プロセスでFIFO両方の口をオープン可能にする
		- ２つのFIFOをオープンするプロセス間のデッドロックを回避する
	- ノンブロッキングread()およびwrite()
	- ...