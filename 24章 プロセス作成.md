- 24.1 概要：fork()、exit()、wait()、execve() ^cb5914
	- exit(status)
		- `wait()システムコール`よりこの終了コードを得る
		- `exit()ライブラリ関数`は内部で`_exit()システムコール`を実行する
		- fork()後に通常どちらか一方が`exit()`、もう一方が`_exit()`を実行
		- `wait(&status)`
			- 2つの目的
				- 子プロセス終了を待つ
				- 終了ステータスを得る
		- `fork()`+`exec()` = `spawn`
		- カーネルが子プロセスの終了を親へ通知する`SIGCHLD`
- 24.2 プロセスの作成：fork()^b64151
	- ネットワークサーバプロセスは接続要求に対しコネクションごとに小プロセスを作成
	- サーバ自身は接続要求受付処理を継続する
	- これにより並行性を同時に獲得している
	- テキストセグメント以外のスタック、データ、ヒープは個別
	- fork()後にどちらのプロセスが先にCPUで実行されるかは固定されていない→[[#^592f2f|24.4 fork()後の競合状態]]
	- sleepで親子の順番の動作を保証はできない
		- より良い方法[[#^fc3c85|24.5 シグナルによる同期を用いた競合状態防止]]
	- 24.2.1 親子プロセス間のファイル共有
		- ファイルオフセット位置は共有される
			- メリットが多い、書き込みを上書きせずに追記できる
			- それ以外の同期として、`wait()システムコール`を使う
- 24.2.2 fork()のメモリ処理
	- 初期UNIXシステムはスワップ領域に親プロセスのメモリをコピーした
	- ２つの技法で無駄コピーを避ける
		- テキストセグメント共有
		- 親プロセスにデータ、ヒープ、スタックセグメントにコピーオンライト（copy-on-write）を適用する
			- `fork()`後にページ内容を変更するとカーネルが新規ページを作成する
	- fork(),wait()併用でプロセスのメモリ消費量最大値を制御する
		- あるfunc()がメモリリークやヒープ断片化を膨大に発生させるとあらかじめわかっている部分の処理
		- ゲームの各局面で次の一手を分析するなど、逐次free()せず割り当てメモリ全てを解放しやすい処理


- 24.4 fork()後の競合状態 ^592f2f
	- 非決定性動作、マルチプロセッサでは同時実行かも
	- システム負荷に応じカーネルにより決定されるスケジューリングに依存するため、発見/再現が困難
	- Linux/x86-32 2.2.19 親プロセスは99.97%先
	- Linux 2.4
		- child first after fork()
	- Linux 2.6.32
		- parent first after fork()
	- 子優先
		- 子はすぐ`exec()`するならコピー自体無駄
	- 親優先
		- fork()時はすでにCPU上で親が動いている
		- メモリ管理情報もMMUのTLB（トランスレーションルックアサイドバッファ）にキャッシュされているから
	- 結論、ほぼ変わらない
- 24.5 シグナルによる同期を用いた競合状態防止 ^fc3c85

- 24.6 章のまとめ ^cd3935
	- `vfork()`は`fork()`より効率だが動作が特殊で通常使用しない
		- 子が`exec()`実行するか終了するまで親のメモリを共有
	- 親子どちらがCPU上にスケジューリングされるかは不定
		- fork競合状態のバグは発見、修正が困難